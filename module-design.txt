- Is namespace a necessary argument?  Maybe because of eval-lib it will show
  up.  Maybe testing repl?  Seems like maybe only used by Pyret, but worth
  keeping for now.

- getFieldLocInternal should be overwritten with a version that no longer
  needs to check for ffi once ffi is available

- Lots of newlines being printed?

- standalone file design

[x] 1. Move srcloc into base/
[x] 2. New copy of ffi-helpers with the right shape
[/] 3. New copy of runtime with "tie the knot" code removed
[/] 4. Write loadBaseModules/loadFlatModules, which will
  - do the work of memomodule
    + done by assigning into modules via URI
  - do any currying massaging necessary to emulate defineModule for pure JS
    + not doing it, just changing the shape of module funs

4.5.
  - find nativeRequires using requirejs
  - Add nativeRequires visibility on locators to kick off pure JS imports
    + Make sure to check existing locators to add get-native-modules!
  - change all js/trove modules to have new object literal shape (including
    nativeRequires)
  - nuke initialize-trove?

[x] 5. "Manually" (e.g. with cat) put 1-3 together with some modules to test
[x] 6. New entrypoint to anf-loop-compiler that generates object literals
       - Added as the compile-module flag in compile options
[x] 7. New make-standalone entrypoint in pyret.arr to create full JS files
[?] 8. Edit compile-lib to work with object literal-shaped files
   - Not sure what happens with the --run option
[x] 9. New builtin/legacy-path locators that find source

10. Centralized place to store serialized compiled modules
    - Remove get-compiled/set-compiled/needs-compile
    - Add "modified-time" to locators
    - cli-module-loader, cpo-module-loader will do their own seralization
      and restoration of compiled files

    ModuleStorage :: {
      load-modules (List<ToCompile> -> MutableStringDict<Loadable>),
      save-modules (List<Loadable> -> Nothing)
    }

[x] 11. Figure out how to checkpoint the dependency list on ffi.  Doing

    "import ffi as _"

    within a user-level module works, but doesn't allow ffi usage in other
    builtin modules.  So maybe adding that line explicitly to the built-in
    modules would work.  Also, doing

    "import ffi as F"

    causes field-not-found errors because the program tries to look up
    "provides," which isn't there since it's a JSModuleReturn.  So it's a bit
    of a mess.

12. Make a location for javascript-defined modules that export JSModuleReturns
rather than Pyret-shaped returns, for e.g. ffi, image-lib, and other JS-to-JS
modules.  This avoids them being import-able from Pyret, which doesn't make
much sense.

[x] 14. Wrangle legacy-path and maybe builtin includes?
    - Change arr/trove modules to have explicit includes for list, etc
    - Ditch legacy path locator, and change all compiler-to-compiler
      imports to use the file locator
    - Make standard-imports be minimal-imports in builtin locator
    - Implement builtin-locator finding and compiling .arr files (if not raw
      js)


15. Build standalone compiler

    node build/phase1/main-wrapper.js --builtin-dir build/phaseA/trove --build-standalone pyret.arr > pyret.js

    node pyret.js --builtin-js src/js/trove/ --builtin-arr src/arr/trove/ --build-standalone pyret.arr > pyret2.js

    node pyret2.js --builtin-js src/js/trove --builtin-arr src/arr/trove/ --build-standalone pyret.arr > pyret3.js

16. How do we REPL?
17. Check mode on a per-file basis to avoid running checks in base modules
18. Right place for printing errors/returning compile results in pyret.arr
    -Â move from cli-module-loader or otherwise centralize
19. Standardize just what fields need to be on a Pyret-shaped return from a
JS-implemented module.  Do we need just provide-plus-types?  answer?  checks?
defined-values/defined-types?  
20. Implement shorthand expansions for type syntax:

  e.g.

  {
    shorthands: {
      "sdOfA": ["tyapp", ["localName", "StringDict"], ["a"]]
    },
    values:
    {
      "make-string-dict": ["forall", ["a"], "sdOfA"]
    }
  }

  or maybe have functions in shorthands


// runtime_anf?
// jsnums.js?


define(["runtime.js"], function(runtimeLib) {
  var staticModules = {

    "builtin://list": {
      provides: ...
      requires: ...
      nativeRequires: ...
      theModule: function(...) { }
    },

    "builtinjs://ffi": {
      provides: ...
      requires: ...
      nativeRequires: ...
      theModule: function(...) {...}
    }

    ...

  };

  var depMap = {
    "builtinjs://ffi": {
      "builtin#lists": "builtin://lists",
      "relpath#./foo.arr": "file://home/joe/src/foo.arr"
    }
  }

  var runtime = runtimeLib.create();

  return runtime.loadBaseModules([list, errors, option, ...], depMap, function(/* intentionally empty */ ) {
    return runtime.loadBaseModules([ffi-helpers], function(ffi) {
      runtime.ffi = ...
      runtime.makeSrcloc = ...
      var topSorted = ["builtin://list", "builtin://errors", "main"];
      var toLoad = topSorted.map(uri) { return staticModules[uri]; };

      return runtime.loadFlatModules(toLoad, function(..., main) {
        printCheckResults(main);
      });
    });
  }

});








var TROVE_LIST = {
  provides: ...
  requires: ...
  nativeRequires: ...
  theModule: function(...) { }
};

var TROVE_ARRAY = {
}


  Seems reasonable to take over from requirejs, manage all deps ourselves,
  including pure JS

- where does something like d3.js come from

  define(["https://raw.github.com/d3-project/d3.js"], function(d3) {
    return {
      provides: ...
      requires: ...
      theModule: ...
    };
  });


  return {
    provides: ...
    requires: ...
    nativeRequires: [
      { protocol: "requireURl", name: "https://raw.github.com/d3-project/d3.js" }
    ],
    theModule: function(runtime, namespace, selfUri, somePyretDep, d3) {
      
    }
  };
  

- Need to address built-in libraries like filesystem, etc.

  return {
    provides: ...
    requires: ...
    nativeRequires: [
      { protocol: "node", name: "fs" }
    ],
    theModule: function(runtime, namespace, fs) {

    }
  };

