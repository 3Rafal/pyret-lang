- Is namespace a necessary argument?  Maybe because of eval-lib it will show
  up.  Maybe testing repl?  Seems like maybe only used by Pyret, but worth
  keeping for now.

- getFieldLocInternal should be overwritten with a version that no longer
  needs to check for ffi once ffi is available

- Lots of newlines being printed?

- standalone file design

[x] 1. Move srcloc into base/
[x] 2. New copy of ffi-helpers with the right shape
[/] 3. New copy of runtime with "tie the knot" code removed
[/] 4. Write loadBaseModules/loadFlatModules, which will
  - do the work of memomodule
    + done by assigning into modules via URI
  - do any currying massaging necessary to emulate defineModule for pure JS
    + not doing it, just changing the shape of module funs
  - find nativeRequires using requirejs
    + not done yet
[x] 5. "Manually" (e.g. with cat) put 1-3 together with some modules to test
[x] 6. New entrypoint to anf-loop-compiler that generates object literals
       - Added as the compile-module flag in compile options
[x] 7. New make-standalone entrypoint in pyret.arr to create full JS files
8. Edit compile-lib to work with object literal-shaped files
9. New builtin/legacy-path locators that find source

10. Centralized place to store serialized compiled modules
    - Remove get-compiled/set-compiled/needs-compile
    - Add "modified-time" to locators
    - cli-module-loader, cpo-module-loader will do their own seralization
      and restoration of compiled files

    ModuleStorage :: {
      load-modules (List<ToCompile> -> MutableStringDict<Loadable>),
      save-modules (List<Loadable> -> Nothing)
    }

11. 


14. Wrangle legacy-path and maybe builtin includes?
    - Change arr/trove modules to have explicit includes for list, etc
    - Ditch legacy path locator, and change all compiler-to-compiler
      imports to use the file locator
    - Make standard-imports be minimal-imports in builtin locator
    - Implement builtin-locator finding and compiling .arr files (if not raw
      js)


15. Build standalone compiler

    node build/phase1/main-wrapper.js --builtin-dir build/phaseA/trove --build-standalone pyret.arr > pyret.js

    node pyret.js --builtin-js src/js/trove/ --builtin-arr src/arr/trove/ --build-standalone pyret.arr > pyret2.js

    node pyret2.js --builtin-js src/js/trove --builtin-arr src/arr/trove/ --build-standalone pyret.arr > pyret3.js

16. How do we REPL?
17. Check mode on a per-file basis to avoid running checks in base modules

// runtime_anf?
// jsnums.js?


define(["runtime.js"], function(runtimeLib) {
  var staticModules = {

    "builtin://list": {
      provides: ...
      requires: ...
      nativeRequires: ...
      theModule: function(...) { }
    },

    "builtinjs://ffi": {
      provides: ...
      requires: ...
      nativeRequires: ...
      theModule: function(...) {...}
    }

    ...

  };

  var depMap = {
    "builtinjs://ffi": {
      "builtin#lists": "builtin://lists",
      "relpath#./foo.arr": "file://home/joe/src/foo.arr"
    }
  }

  var runtime = runtimeLib.create();

  return runtime.loadBaseModules([list, errors, option, ...], depMap, function(/* intentionally empty */ ) {
    return runtime.loadBaseModules([ffi-helpers], function(ffi) {
      runtime.ffi = ...
      runtime.makeSrcloc = ...
      var topSorted = ["builtin://list", "builtin://errors", "main"];
      var toLoad = topSorted.map(uri) { return staticModules[uri]; };

      return runtime.loadFlatModules(toLoad, function(..., main) {
        printCheckResults(main);
      });
    });
  }

});








var TROVE_LIST = {
  provides: ...
  requires: ...
  nativeRequires: ...
  theModule: function(...) { }
};

var TROVE_ARRAY = {
}


  Seems reasonable to take over from requirejs, manage all deps ourselves,
  including pure JS

- where does something like d3.js come from

  define(["https://raw.github.com/d3-project/d3.js"], function(d3) {
    return {
      provides: ...
      requires: ...
      theModule: ...
    };
  });


  return {
    provides: ...
    requires: ...
    nativeRequires: [
      { protocol: "requireURl", name: "https://raw.github.com/d3-project/d3.js" }
    ],
    theModule: function(runtime, namespace, selfUri, somePyretDep, d3) {
      
    }
  };
  

- Need to address built-in libraries like filesystem, etc.

  return {
    provides: ...
    requires: ...
    nativeRequires: [
      { protocol: "node", name: "fs" }
    ],
    theModule: function(runtime, namespace, fs) {

    }
  };

