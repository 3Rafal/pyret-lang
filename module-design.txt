- Is namespace a necessary argument?  Maybe because of eval-lib it will show
  up.  Maybe testing repl?  Seems like maybe only used by Pyret, but worth
  keeping for now.

- getFieldLocInternal should be overwritten with a version that no longer
  needs to check for ffi once ffi is available

- standalone file design

[x] 1. Move srcloc into base/
[x] 2. New copy of ffi-helpers with the right shape
[/] 3. New copy of runtime with "tie the knot" code removed
[/] 4. Write loadBaseModules/loadFlatModules, which will
  - do the work of memomodule
    + done by assigning into modules via URI
  - do any currying massaging necessary to emulate defineModule for pure JS
    + not doing it, just changing the shape of module funs
  - find nativeRequires using requirejs
    + not done yet
[/] 5. "Manually" (e.g. with cat) put 1-3 together with some modules to test
6. New entrypoint to anf-loop-compiler that generates object literals

// runtime_anf?
// jsnums.js?


define(["runtime.js"], function(runtimeLib) {
  var staticModules = {

    "builtin://list": {
      provides: ...
      requires: ...
      nativeRequires: ...
      theModule: function(...) { }
    },

    "builtinjs://ffi": {
      provides: ...
      requires: ...
      nativeRequires: ...
      theModule: function(...) {...}
    }

    ...

  };

  var depMap = {
    "builtinjs://ffi": {
      "builtin#lists": "builtin://lists",
      "relpath#./foo.arr": "file://home/joe/src/foo.arr"
    }
  }

  var runtime = runtimeLib.create();

  return runtime.loadBaseModules([list, errors, option, ...], depMap, function(/* intentionally empty */ ) {
    return runtime.loadBaseModules([ffi-helpers], function(ffi) {
      runtime.ffi = ...
      runtime.makeSrcloc = ...
      var topSorted = ["builtin://list", "builtin://errors", "main"];
      var toLoad = topSorted.map(uri) { return staticModules[uri]; };

      return runtime.loadFlatModules(toLoad, function(..., main) {
        printCheckResults(main);
      });
    });
  }

});








var TROVE_LIST = {
  provides: ...
  requires: ...
  nativeRequires: ...
  theModule: function(...) { }
};

var TROVE_ARRAY = {
}


  Seems reasonable to take over from requirejs, manage all deps ourselves,
  including pure JS

- where does something like d3.js come from

  define(["https://raw.github.com/d3-project/d3.js"], function(d3) {
    return {
      provides: ...
      requires: ...
      theModule: ...
    };
  });


  return {
    provides: ...
    requires: ...
    nativeRequires: [
      { protocol: "requireURl", name: "https://raw.github.com/d3-project/d3.js" }
    ],
    theModule: function(runtime, namespace, selfUri, somePyretDep, d3) {
      
    }
  };
  

- Need to address built-in libraries like filesystem, etc.

  return {
    provides: ...
    requires: ...
    nativeRequires: [
      { protocol: "node", name: "fs" }
    ],
    theModule: function(runtime, namespace, fs) {

    }
  };

