dynamic-modules, - Is namespace a necessary argument?  Maybe because of eval-lib it will show
  up.  Maybe testing repl?  Seems like maybe only used by Pyret, but worth
  keeping for now.

- getFieldLocInternal should be overwritten with a version that no longer
  needs to check for ffi once ffi is available

- Lots of newlines being printed?

- standalone file design

[x] 1. Move srcloc into base/
[x] 2. New copy of ffi-helpers with the right shape
[/] 3. New copy of runtime with "tie the knot" code removed
[/] 4. Write loadBaseModules/loadFlatModules, which will
  - do the work of memomodule
    + done by assigning into modules via URI
  - do any currying massaging necessary to emulate defineModule for pure JS
    + not doing it, just changing the shape of module funs

[x] 4.5.
  - find nativeRequires using requirejs
  - Add nativeRequires visibility on locators to kick off pure JS imports
    + Make sure to check existing locators to add get-native-modules!
  - change all js/trove modules to have new object literal shape (including
    nativeRequires)
  - nuke initialize-trove?

[x] 5. "Manually" (e.g. with cat) put 1-3 together with some modules to test
[x] 6. New entrypoint to anf-loop-compiler that generates object literals
       - Added as the compile-module flag in compile options
[x] 7. New make-standalone entrypoint in pyret.arr to create full JS files
[?] 8. Edit compile-lib to work with object literal-shaped files
   - Not sure what happens with the --run option
[x] 9. New builtin/legacy-path locators that find source

[x] 10. Centralized place to store serialized compiled modules
    - Remove get-compiled/set-compiled/needs-compile
    - Add "modified-time" to locators
    - cli-module-loader, cpo-module-loader will do their own seralization
      and restoration of compiled files

    ModuleStorage :: {
      load-modules (List<ToCompile> -> MutableStringDict<Loadable>),
      save-modules (List<Loadable> -> Nothing)
    }

[x] 11. Figure out how to checkpoint the dependency list on ffi.  Doing

    "import ffi as _"

    within a user-level module works, but doesn't allow ffi usage in other
    builtin modules.  So maybe adding that line explicitly to the built-in
    modules would work.  Also, doing

    "import ffi as F"

    causes field-not-found errors because the program tries to look up
    "provides," which isn't there since it's a JSModuleReturn.  So it's a bit
    of a mess.

12. Make a location for javascript-defined modules that export JSModuleReturns
rather than Pyret-shaped returns, for e.g. ffi, image-lib, and other JS-to-JS
modules.  This avoids them being import-able from Pyret, which doesn't make
much sense.

[x] 14. Wrangle legacy-path and maybe builtin includes?
    - Change arr/trove modules to have explicit includes for list, etc
    - Ditch legacy path locator, and change all compiler-to-compiler
      imports to use the file locator
    - Make standard-imports be minimal-imports in builtin locator
    - Implement builtin-locator finding and compiling .arr files (if not raw
      js)


[x] 15. Build standalone compiler

    node build/phase1/main-wrapper.js --builtin-dir build/phaseA/trove --build-standalone pyret.arr > pyret.js

    node pyret.js --builtin-js src/js/trove/ --builtin-arr src/arr/trove/ --build-standalone pyret.arr > pyret2.js

    node pyret2.js --builtin-js src/js/trove --builtin-arr src/arr/trove/ --build-standalone pyret.arr > pyret3.js

[x] 15a. Check mode on a per-file basis to avoid running checks in base modules
    (e.g. method on locator)
[/] 15b. Make tests run again
    - Aside from some eval tests, these work
15c. Refactor locators to get rid of common implementations of shared methods
    - Also get rid of unused methods – get-provides, set-compiled, needs-compile
15d. Building tests as standalone requires recompiling lots of the compiler.
     Should we support read-only access to multiple compiled/ directories in
     order to make that work better?  We could have the module cache just read
     from, but not write to, things like phaseA/compiled/, to avoid
     regenerating ast.arr and whatnot every time.  This gets into tricky
     staleness/recompile questions.
[/] 16. Some kind of eval probably needed for some of 15b
  - Refactoring to find a good place for the shared load hooks
  - Rendering checks and error messages by loading the right runtime's modules
17. How do we REPL?
    [x] - runStandalone doesn't have the ability to pass anything but the default
      namespace in for all modules.  Current repl impl requires passing in a
      different one
    - Let's get variables right, please
    - Let's handle #190 as well
    [x] - Need to put provide information on compiled modules so cached modules
      give the correct information about environment (also needed for type
      checker).  Basics done – just "tany" for all
18. Right place for printing errors/returning compile results in pyret.arr
    - move from cli-module-loader or otherwise centralize
19. Standardize just what fields need to be on a Pyret-shaped return from a
JS-implemented module.  Do we need just provide-plus-types?  answer?  checks?
defined-values/defined-types?
20. types

  - generate type information into provides in the compiler (needed in general)

  - Make it so get-compiled tells us whether we have serialized information or
    not, instead of the module cache.  That way, those serialized provides can
    be resolved, and then the cache on compile-program is just internal to the
    algorithm.  Once resolved, they will be in the cache and not need to be
    reconstructed again.  This means compile-module will "do work" on pure JS
    modules, because they will have unresolved types stored.

    It may be useful to store _some_ unresolved types.

  - Implement shorthand expansions for type syntax:
  e.g.

  {
    shorthands: {
      "sdOfA": ["tyapp", ["localName", "StringDict"], ["a"]]
    },
    values:
    {
      "make-string-dict": ["forall", ["a"], "sdOfA"]
    }
  }

21. Create a pyret.arr option for dumping a dependency list to enable parallel builds
22. It's pretty annoying to have to specify the source of libraries (which get
    recompiled, see #15d) when starting from a standalone.  Need a solution for
    system libraries, perhaps "baked in" to the binary, or done as an
    environment variable.  Could also quote the source of built-in libraries
    and have a locator that searches inside the standalone for the source
    copies to recompile/reinstantiate.

    Basically, if I ship someone the Pyret binary, what should happen to the
    --builtin-js-dir and --builtin-arr-dir when they want to build their own
    standalone?  Do they need their own compiled copies of lists, outside the
    standalone, to build their own standalone?  Or can the standalone itself
    hold the copies of the library?  Or should the libraries always be
    dynamically linked, and use requirejs in a clever way to reference the
    right place on the filesystem?

    [x] CPO does this with cpo-builtin-modules and realms.
        This can be adopted for the standalone

23. Various errors:
  - Where/how is an error in runStandalone reported?
  - Should the answer for main be returned as a failure in postLoadHooks, or do
    you find out through the failure cont?
  - How do you know during which module execution the run failed?
[x] 24. Always compile with the "compile-module" flag true, and deprecate the other
    version
[x] 25. Add a new jsfile locator to support importing/using js files as modules
    outside of trove/.  Needed for CPO to define its internal modules
26. Remove everything to do with namespace!
    - Change it to realm, maybe?
[x] 27. For CPO, need a different builtin locator that looks up builtins from
    the provided program dict.
[x] 28. Add a dynamicModules argument to runStandalone, and use that rather than
    runtime.modules as the cache/storage place for instantiated modules, and
    delegate management and evicting compiled modules to the surrounding
    context (e.g. the REPL can manage this).
    - Added as "realms"
[x] 29. Make the REPL/CPO main store compiled modules in a useful way, perhaps in
    memory while an interaction is running, and in localStorage in between runs

    cpo-builtin-modules/realms does this

[ ] 30. Delete legacy-path and `pre-loaded` module type

[ ] 31. Just use get-compiled to streamline caching of modules, and don't pass
    in the initial cache?  That is, locator constructors like file could
    take an Option<Loadable>

[ ] 32. We never use the compile-env field in loadables, or the pre-loaded
    variant of Loadable

[ ] 33. What is going on with the error in numbers with tME not a function?  Hard to
    reproduce.

[ ] 34. Checker instantiation.

--

New rules for requirejs:

- All pyret-shaped js modules need to use a require base, because they can get
  moved around by the compiler.
- All other requirejs modules can use relative paths, as long as they do not
  use parent references past their root
- The Pyret compiler must be passed a requirejs config that tells it where to
  find all the roots (including builtin Pyret stuff, for now).

----

  maybe have functions in shorthands


// runtime_anf?
// jsnums.js?


define(["runtime.js"], function(runtimeLib) {
  var staticModules = {

    "builtin://list": {
      provides: ...
      requires: ...
      nativeRequires: ...
      theModule: function(...) { }
    },

    "builtinjs://ffi": {
      provides: ...
      requires: ...
      nativeRequires: ...
      theModule: function(...) {...}
    }

    ...

  };

  var depMap = {
    "builtinjs://ffi": {
      "builtin#lists": "builtin://lists",
      "relpath#./foo.arr": "file://home/joe/src/foo.arr"
    }
  }

  var runtime = runtimeLib.create();

  return runtime.loadBaseModules([list, errors, option, ...], depMap, function(/* intentionally empty */ ) {
    return runtime.loadBaseModules([ffi-helpers], function(ffi) {
      runtime.ffi = ...
      runtime.makeSrcloc = ...
      var topSorted = ["builtin://list", "builtin://errors", "main"];
      var toLoad = topSorted.map(uri) { return staticModules[uri]; };

      return runtime.loadFlatModules(toLoad, function(..., main) {
        printCheckResults(main);
      });
    });
  }

});








var TROVE_LIST = {
  provides: ...
  requires: ...
  nativeRequires: ...
  theModule: function(...) { }
};

var TROVE_ARRAY = {
}


  Seems reasonable to take over from requirejs, manage all deps ourselves,
  including pure JS

- where does something like d3.js come from

  define(["https://raw.github.com/d3-project/d3.js"], function(d3) {
    return {
      provides: ...
      requires: ...
      theModule: ...
    };
  });


  return {
    provides: ...
    requires: ...
    nativeRequires: [
      { protocol: "requireURl", name: "https://raw.github.com/d3-project/d3.js" }
    ],
    theModule: function(runtime, namespace, selfUri, somePyretDep, d3) {

    }
  };


- Need to address built-in libraries like filesystem, etc.

  return {
    provides: ...
    requires: ...
    nativeRequires: [
      { protocol: "node", name: "fs" }
    ],
    theModule: function(runtime, namespace, fs) {

    }
  };








-----
Older design sketch:


define(["trove/either",
"trove/equality",
"trove/option",
"trove/valueskeleton"],function($E30,$equality31,$O32,$VS33) {

  return {
    dependencies: [
      { name: "either" },
      { name: "equality" }
    ],
    provides: [
      ...
    ],
    oldDependencies: [ $E30, $equality31 ],
    theModule: function($E30, $equality31) {
      return function(r, ns) {
        return r.loadModulesNew([$E30, $equality31], function($E30, $equality31) {

          compiled body

        }
      }
    }
  };

}

var MODULES = {};
function legacyResolve(url) {
  return MODULES[url] || require(url);
}

// MODULES["legacy-path://anf-loop-compiler.arr"] = (function($ANF) {

//})(legacyResolve("legacy-path://ast-anf.arr"));
define(["compiler/ast-anf.arr"],function(ANF$3) {

  return {
    dependencies: [
      { protocol: "legacy-path", args: ["compiler/ast-anf.arr"] },
    ],
    provides: [
      ...
    ],
    oldDependencies: [ ANF$3 ],
    theModule: function(ANF$3) {
      return function(r, ns) {
        return r.loadModulesNew([$E30, $equality31], function($E30, $equality31) {

          compiled body

        }
      }
    }
  };

}
