Redex
[] Redex the initial semantics
  [] basic objects
  [] seals
  [] extending
[] Come up with a define-split-test form that makes a test run on both
   the Redex semantics and the Racket interpreter (may require a
   compile-value function over answers & exceptions...)
[] Go from Redex-generated terms to AST so we can randomly test the
   Racket implementation as well
[] add s-let and pyret compile let

HTDP:
[x] allow hyphens in identifiers
[x] constructed types
[] Think MOAR about self-reference/method invocation
  [] first class methods
[x] Change Number/String/Bool into a-names
[] Have mk-num/str/bool brand
[] Have global brand checkers for num/str/bool
[] Desugar function annotations into checks for these brands
[] Actually compile annotations to checks

[] surface syntax for operators?
[] Desugar data
  [] Lock operator for immutability
  [] Brand checks on struct creation
  [] Annotations actually checked
  [x] Skeleton of struct/data desugaring
[] anonymous functions... :-)
[] brand names for debugging and general user-friendliness
[] pretty-printing objects
   - Take brands into account (names for them)
[] None/null/nothing value built in
[] Lists built in
[] How should short-circuiting booleans work?


Cleanup:
[x] make helper for id-parsing
[] and str-parsing in pyret.rkt
[] decide on a line length and enforce
[] ordering of things in grammar vs pyret.rkt
[] consistent naming in grammar for lists of things
[] figure out what define-syntax is less boilerplate
[] s-data and s-dot should agree on symbol vs. string
[] clean up runtime.rkt into sanity
[] stop using typed racket except for data definitions
[] figure out duplicate identifiers with (define)
[] can we use ()? instead of multiple arms in grammar.rkt?
[] bug report on module docs for language definitions
[] bug report on resolved-module-path? docs

[] application should check type better?

[x] syntax for rudimentary types ::
[] checking for rudimentary types

[] Escape into Racket with peglegs:
    !(display (current-namespace))!
  - wrapping where possible?
[] Racket.builtin for convenient libraries
  - e.g. Racket.string-append(pyval, pyval)
  - unwrapping and wrapping of pyret constants to Racket #'s and str's

